<?xml version="1.0" encoding="UTF-8"?>

  <!-- 
    This is a copy of geoserver's applicationSecurityContext with important
    additions and changes noted with a comment starting with GEONODE
  -->
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:sec="http://www.springframework.org/schema/security"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
          http://www.springframework.org/schema/security
          http://www.springframework.org/schema/security/spring-security-3.0.4.xsd">
  
  <bean id="filterChainProxy" class="org.geoserver.security.GeoServerSecurityFilterChainProxy">
    <constructor-arg ref="authenticationManager"/>
  </bean>

  <!--
      HTTP Method security rules.  This follows the same format as the normal DefinitionSource, but allows methods to be specified as well.
      Remember that rules are matched in order, so please put the most specific rules at the beginning of the list.
      In order to have these applied, add restFilterDefintionMap to the end of the filter list in the filterChainProxy above
  -->
  <bean id="restFilterDefinitionMap" class="org.geoserver.security.RESTfulDefinitionSource">
      <constructor-arg ref="restRulesDao"/>
  </bean>

  <bean id="geoserverMetadataSource" class="org.geoserver.security.filter.GeoServerSecurityMetadataSource" />

  <!--
    The actual remember-me cookie handler
  -->
  <bean id="rememberMeServices"
    class="org.geoserver.security.rememberme.RememberMeServicesFactoryBean">
    <constructor-arg ref="geoServerSecurityManager"/>
  </bean>

  <!-- global security manager -->
  <!-- 
    GEONODE: We are overriding the default security manager facade to customize it.
  -->
  <bean id="authenticationManager" class="org.geoserver.security.GeoNodeSecurityManager"
     depends-on="extensions">
    <constructor-arg index="0" ref="dataDirectory"/>
    <constructor-arg index="1" ref="geonodeSecurityClient"/>
    <property name="eraseCredentialsAfterAuthentication" value="false"/>  	  
  </bean>
  <alias name="authenticationManager" alias="geoServerSecurityManager"/>

 
  <!-- password encoders -->
  <bean id="emptyPasswordEncoder"
    class="org.geoserver.security.password.GeoServerEmptyPasswordEncoder">
  </bean>
  <bean id="plainTextPasswordEncoder"        
    class="org.geoserver.security.password.GeoServerPlainTextPasswordEncoder">
    <property name="prefix" value="plain" />
  </bean>
  <bean id="pbePasswordEncoder"    
    class="org.geoserver.security.password.GeoServerPBEPasswordEncoder" scope="prototype">
    <property name="prefix" value="crypt1" />
    <property name="algorithm" value="PBEWITHMD5ANDDES" />
  </bean>
  <bean id="strongPbePasswordEncoder"    
    class="org.geoserver.security.password.GeoServerPBEPasswordEncoder" scope="prototype">
    <property name="prefix" value="crypt2" />
    <property name="providerName" value="BC" />
    <property name="algorithm" value="PBEWITHSHA256AND256BITAES-CBC-BC" />
    <property name="availableWithoutStrongCryptogaphy" value="false" />
  </bean>  
  <bean id="digestPasswordEncoder"    
    class="org.geoserver.security.password.GeoServerDigestPasswordEncoder" scope="prototype">
    <property name="prefix" value="digest1" />    
  </bean>
  
    
  <!--
  Extensions can inject another class implementing org.geoserver.security.KeyStoreProvider   
  <bean id="keyStoreProvider" class="org.geoserver.security.KeyStoreProviderImpl" />
   -->
   
  <bean id="roleConverter" class="org.geoserver.security.impl.GeoServerRoleConverterImpl" >  
  	<property name="roleDelimiterString" value=";" />
  	<property name="roleParameterDelimiterString" value=","/>
  	<property name="roleParameterStartString" value="("/>
  	<property name="roleParameterEndString" value= ")"/>
  	<property name="roleParameterAssignmentString" value="="/>  
  </bean>
  
   

  <bean id="xmlSecurityProvider" class="org.geoserver.security.xml.XMLSecurityProvider"/>
  <bean id="basicAuthSecurityProvider" class="org.geoserver.security.filter.GeoServerBasicAuthenticationProvider"/>
  <bean id="digestAuthSecurityProvider" class="org.geoserver.security.filter.GeoServerDigestAuthenticationProvider"/>
  <bean id="roleFilterProvider" class="org.geoserver.security.filter.GeoServerRoleProvider"/>
  <bean id="j2eeAuthSecurityProvider" class="org.geoserver.security.filter.GeoServerJ2eeAuthenticationProvider"/>
  <bean id="requestHeaderFilterProvider" class="org.geoserver.security.filter.GeoServerRequestHeaderAuthenticationProvider"/>
  <bean id="exceptionTranslationFilterProvider" class="org.geoserver.security.filter.GeoServerExceptionTranslationProvider"/>
  <bean id="usernamePasswordFilterProvider" class="org.geoserver.security.filter.GeoServerUserNamePasswordAuthenticationProvider"/>
  <bean id="x509FilterProvider" class="org.geoserver.security.filter.GeoServerX509CertificateAuthenticationProvider"/>
  <bean id="contextPersistenceProvider" class="org.geoserver.security.filter.GeoServerSecurityContextPersistenceProvider"/>  
  <bean id="rememberMeFilterProvider" class="org.geoserver.security.filter.GeoServerRememberMeAuthenticationProvider"/>
  <!-- GEONODE - our custom anonymousFilter -->
  <bean id="anonymousFilterProvider" class="org.geonode.security.GeoNodeAnonymousProcessingFilterProvider">
    <constructor-arg index="0" ref="geonodeSecurityClient"/>
  </bean>
  <bean id="logoutFilterProvider" class="org.geoserver.security.filter.GeoServerLogoutProvider"/>  
  <bean id="securityInterceptorFilterProvider" class="org.geoserver.security.filter.GeoServerSecurityInterceptorProvider"/>  
  
  <bean id="urlMasterPasswordProvider" 
    class="org.geoserver.security.password.URLMasterPasswordProvider$SecurityProvider"/>
  
  <!-- The dao used to deal with layer level security -->
  <bean id="accessRulesDao" class="org.geoserver.security.impl.DataAccessRuleDAO">
  	<constructor-arg ref="dataDirectory"/>
  	<constructor-arg ref="rawCatalog"/>
  </bean>
  
  <!-- The dao used to deal with service level security -->
  <bean id="serviceRulesDao" class="org.geoserver.security.impl.ServiceAccessRuleDAO">
    <constructor-arg ref="dataDirectory"/>
  	<constructor-arg ref="rawCatalog"/>
  </bean>

  <!-- The dao used to deal with rest security -->
  <bean id="restRulesDao" class="org.geoserver.security.impl.RESTAccessRuleDAO">
    <constructor-arg ref="dataDirectory"/>
  </bean>
  
  <!-- 
    This callback will be used before calling operations on OWS stuff, and making it secure
   -->
  <bean id="operationCallback"
    class="org.geoserver.security.OperationSecurityCallback">
    <constructor-arg ref="serviceRulesDao"/>
  </bean>
              
  
  

  <!-- 
    This filter does the actual main authentication workflow and handles form based authentication too.
    It asks the authentication manager whether access is granted to the resource the user is trying to access,
    redirects to a failure page if it fails, and to another filter if the authentication informations are 
    just being provided. This is useful only for form based authentication, the OWS services do use another
    authentication processing filter.
  -->
  <bean id="gnAuthenticationProcessingFilter"
    class="org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter">
    <property name="authenticationManager" ref="gnAuthenticationManager" />
<!--    <property name="authenticationFailureHandler" ref="failureHandler"/>-->
<!--    <property name="authenticationSuccessHandler" ref="successHandler"/>-->
    <property name="filterProcessesUrl" value="/j_spring_security_check" />
    <property name="allowSessionCreation" value="false"/>
  </bean>


  <!-- 
    Handles the basic authentication headers.
  -->
  <bean id="gnBasicProcessingFilter"
    class="org.springframework.security.web.authentication.www.BasicAuthenticationFilter">
    <property name="authenticationManager">
      <ref local="gnAuthenticationManager" />
    </property>
    <property name="authenticationEntryPoint">
      <ref local="basicProcessingFilterEntryPoint" />
    </property>
  </bean>

  <!-- 
    The bean managing authentication, basically forwards authentication requests against
    a number of child providers
  -->
  <bean id="gnAuthenticationManager"
    class="org.springframework.security.authentication.ProviderManager">
    <property name="providers">
      <list>
        <ref local="geonodeAuthenticationProvider" />
        <bean
          class="org.springframework.security.authentication.AnonymousAuthenticationProvider">
          <property name="key" value="geoserver" />
        </bean>
      </list>
    </property>
  </bean>
 
  <bean id="geonodeHttpClient" class="org.geonode.security.HTTPClient">
    <description>httpclient used by geonodeSecurityClient to request authentication to GeoNode</description>
    <constructor-arg index="0">
      <description>Max connections per host</description>
      <value>10</value>
    </constructor-arg>
    <constructor-arg index="1">
      <description>Connection time out in milliseconds</description>
      <value>1000</value>
    </constructor-arg>
    <constructor-arg index="2">
      <description>Read time out in milliseconds</description>
      <value>1000</value>
    </constructor-arg>
  </bean>
  
  <!-- The client talking to GeoNode to get authentications from cookies and username/password -->
  <bean id="geonodeSecurityClient" class="org.geonode.security.DefaultSecurityClient">
    <!-- We probably need to add a reference to the data directory here -->
    <constructor-arg ref="geonodeHttpClient"/>
  </bean>
  
  <!-- The GeoNode username/password manager -->
  <bean id="geonodeAuthenticationProvider" class="org.geonode.security.GeoNodeAuthenticationProvider">
    <constructor-arg index="0" ref="geonodeSecurityClient"/>
  </bean>

  <!-- The GeoNode cookie processing filter -->
  <bean id="geonodeCookieFilter" class="org.geonode.security.GeoNodeCookieProcessingFilter">
    <constructor-arg index="0" ref="geonodeSecurityClient"/>
  </bean>
  
  <!-- The custom data access manager using the GeoNode granted authorities -->
  <!-- GEONODE: this is picked up via a spring context lookup for the interface -->
  <bean id="geonodeAccessManager" class="org.geonode.security.GeoNodeDataAccessManager"/>
  
  <!-- 
    This entry point gets called when basic authentication is needed 
    (or a previous attempt fail) to commence authentication 
    with the basic processing filter 
  -->
  <bean id="basicProcessingFilterEntryPoint"
    class="org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint">
    <property name="realmName">
      <value>GeoServer Realm</value>
    </property>
  </bean>

  <!-- 
    The actual authorization checks at the filter level. 
    The voters make sure the user is both authenticated (the 
    anonymous filter ensures there is at least an anonymous one)
    and have the roles required.
    The objectDefinitionSource provides a set of path along with the
    roles that the user must have in order to access the secured resource
  -->
  <!-- NOT SURE IF NEEDED ?
  <bean id="filterInvocationInterceptor"
    class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor">
    <property name="authenticationManager" ref="gnAuthenticationManager" />
    <property name="accessDecisionManager">
      <bean class="org.springframework.security.access.vote.AffirmativeBased">
        <property name="allowIfAllAbstainDecisions" value="false" />
        <property name="decisionVoters">
          <list>
            <bean class="org.springframework.security.access.vote.RoleVoter" />
            <bean class="org.springframework.security.access.vote.AuthenticatedVoter" />
          </list>
        </property>
      </bean>
    </property>
    <property name="securityMetadataSource">
        <sec:filter-security-metadata-source lowercase-comparisons="true" path-type="ant">
            <sec:intercept-url pattern="/config/**" access="ROLE_ADMINISTRATOR"/>
            <sec:intercept-url pattern="/**" access="IS_AUTHENTICATED_ANONYMOUSLY"/>
        </sec:filter-security-metadata-source>
    </property>
  </bean>
  -->

</beans>
