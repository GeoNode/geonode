{% include "geonode/ext_header.html" %}
{# {% include "geonode/app_header.html" %} #}
{#  {% include "maptiles/maptiles_header.html" %} #}
<link rel="stylesheet" type="text/css" href="{{ STATIC_URL }}geoext/css/popup.css">
<script type="text/javascript" src="{{STATIC_URL}}lib/js/OpenLayers.js"></script>
<script type="text/javascript" src="{{ STATIC_URL }}lib/js/GeoExt.js"></script>
<script type="text/javascript" src="{{ STATIC_URL}}geonode/js/utils/thumbnail.js"></script>
<script type="text/javascript" src="http://svn.osgeo.org/metacrs/proj4js/trunk/lib/proj4js-compressed.js"></script>
<!--<script type="text/javascript" src="http://spatialreference.org/ref/epsg/wgs-84-utm-zone-51n/proj4js/"></script>-->

<script type="text/javascript" src="http://spatialreference.org/ref/epsg/32651/proj4js/"></script>
<script type="text/javascript" >

OpenLayers.ImgPath = "{{ STATIC_URL }}geoexplorer/externals/openlayers/theme/default/img";
OpenLayers.Request.DEFAULT_CONFIG.headers = {
    'X-CSRFToken': '{{ csrf_token|escapejs }}'
};

OpenLayers.ProxyHost = "http://192.168.56.100:8000/proxy/?url=";

{% autoescape off %}

var options = {{ viewer| safe }};
var app;
var bounds_list = [];
var tile_list = [];
var curr_popup;
// added stuff

var _TILE_SIZE = 1000;

function floor_tile_size(x){
    return  (Math.floor(x/_TILE_SIZE) * _TILE_SIZE);
}

function ceil_tile_size(x) {
    return (Math.ceil(x/_TILE_SIZE) * _TILE_SIZE);
}

function get_corners( x, y ){
    return { ul_x: floor_tile_size(x), ul_y: ceil_tile_size(y),
         ur_x: ceil_tile_size(x), ur_y: ceil_tile_size(y),
         ll_x: floor_tile_size(x), ll_y: floor_tile_size(y),
         lr_x: ceil_tile_size(x), lr_y: floor_tile_size(y)
        };
}

function display_points(div_id, vec_layer){
    console.log(div_id);
    var container = document.getElementById(div_id);
    container.removeChild(container.firstElementChild||container.firstChild);
    var list_element = document.createElement("ul");
    container.appendChild(list_element);
    
    var georef_string = "";
    
    for (var i=0; i< tile_list.length; i++){
        var item_element = document.createElement("li");
        item_element.setAttribute("id",tile_list[i].georef);
        item_element.innerHTML = tile_list[i].georef;
        item_element.onclick = function(){
            removeHighlight(item_element.innerHTML, vec_layer);
            this.parentNode.removeChild(this);
        };
        list_element.appendChild(item_element);
        georef_string+=tile_list[i].georef+",";
    }
   document.getElementById("georef_area").setAttribute("value",georef_string);
}

function createHighlightBox(feature_attribs){
    var pt1 = new OpenLayers.Geometry.Point(feature_attribs["ul_x"], feature_attribs["ul_y"]).transform(new OpenLayers.Projection("EPSG:32651"), new OpenLayers.Projection("EPSG:900913"));
    var pt2 = new OpenLayers.Geometry.Point(feature_attribs["ur_x"], feature_attribs["ur_y"]).transform(new OpenLayers.Projection("EPSG:32651"), new OpenLayers.Projection("EPSG:900913"));
    var pt3 = new OpenLayers.Geometry.Point(feature_attribs["lr_x"], feature_attribs["lr_y"]).transform(new OpenLayers.Projection("EPSG:32651"), new OpenLayers.Projection("EPSG:900913"));
    var pt4 = new OpenLayers.Geometry.Point(feature_attribs["ll_x"], feature_attribs["ll_y"]).transform(new OpenLayers.Projection("EPSG:32651"), new OpenLayers.Projection("EPSG:900913"));
    
    var pts = [pt1, pt2, pt3, pt4];
    var lr = new OpenLayers.Geometry.LinearRing(pts);
    var polygon  = new OpenLayers.Geometry.Polygon([lr]);
    var polygon_feature = new  OpenLayers.Feature.Vector(polygon);
    
    return polygon_feature;
}

function find_georef(tile_list, georef){
     var tile_indeces= tile_list.map(function (x) { return x.georef });
     
     var index = tile_indeces.indexOf(georef);
     return index;
}

function removeHighlight(georef, vec_layer){
    var index= find_georef(tile_list, georef);
    vec_layer.removeFeatures([tile_list[index].feature]);
    tile_list.splice(index,1);
}

var vector_style = new OpenLayers.Style({
    'fillColor': '#0000ff',
    'strokeColor': '#0000ff',
    'strokeWidth': 1
});

var vector_style_map = new OpenLayers.StyleMap({
    'default': vector_style
});

Ext.onReady(function (){
    var curr_location = window.location.hostname;
    var layer_name = "{{  layer }}";
    var map_options = options["map"];
    var map = new OpenLayers.Map({
        units: map_options["units"],
        maxResolution: map_options["maxResolution"],
        projection: map_options["projection"]
    });
    
    var mq_layer = new OpenLayers.Layer.XYZ(
        "OpenStreetMap",
        [
            "http://otile1.mqcdn.com/tiles/1.0.0/map/${z}/${x}/${y}.png",
            "http://otile2.mqcdn.com/tiles/1.0.0/map/${z}/${x}/${y}.png",
            "http://otile3.mqcdn.com/tiles/1.0.0/map/${z}/${x}/${y}.png",
            "http://otile4.mqcdn.com/tiles/1.0.0/map/${z}/${x}/${y}.png"
        ],
        {
            attribution: "Data, imagery and map information provided by <a href='http://www.mapquest.com/'  target='_blank'>MapQuest</a>, <a href='http://www.openstreetmap.org/' target='_blank'>Open Street Map</a> and contributors, <a href='http://creativecommons.org/licenses/by-sa/2.0/' target='_blank'>CC-BY-SA</a>  <img src='http://developer.mapquest.com/content/osm/mq_logo.png' border='0'>",
            transitionEffect: "resize"
        },
        {
            isBaseLayer: true,
            wrapDateLine: true
        }
    );
    
    var stored_layer = map_options["layers"].filter(function(l){ return l["name"] == layer_name })[0];
    var source_index = stored_layer["source"];
    //var geoserver_wms = options["sources"][source_index]["url"];
    var geoserver_wms = "http://"+curr_location+":8080/geoserver/geonode/wms";
    
    var tile_layer = new OpenLayers.Layer.WMS(
        layer_name + "- Tiled", geoserver_wms,
        {
            LAYERS: stored_layer["name"],
            format:  'image/png',
            bbox: stored_layer["bbox"],
            transparent: true,
            opacity: 0.3
        },
        {
            buffer: 0,
            displayOutsideMaxExtent: true,
            isBaseLayer: false,
            projection: "EPSG:900913",
            maxExtent: new OpenLayers.Bounds(stored_layer["bbox"])
        } 
    );
    
    var highlight_layer = new OpenLayers.Layer.Vector(
        "Highlight Layer",
        {
            isBaseLayer: false ,
            //styleMap: new OpenLayers.Style(OpenLayers.Feature.Vector.style["select"])
            styleMap: vector_style_map,
            visibility: true,
            transparent: true
        }
    );
    
    map.addLayers([mq_layer,tile_layer,highlight_layer]);
    
    var items = [];
    var config = {
        renderTo: "preview_map",
        height: 400,
        map: map,
        title: "Tile Selection",
        items: items,
        center: [13652590.86,1366919.96],
        zoom: 5
    };

    var drawControl = new OpenLayers.Control();
    OpenLayers.Util.extend(drawControl, {
        draw: function () {
            // this Handler.Box will intercept the shift-mousedown
            // before Control.MouseDefault gets to see it
            this.box = new OpenLayers.Handler.Box( drawControl,
                {"done": this.notice},
                {keyMask: OpenLayers.Handler.MOD_SHIFT});
            this.box.activate();
        },
        
        notice: function (bounds) {
            
            console.log("bounds:"+bounds);
            
            var ll = map.getLonLatFromPixel(new OpenLayers.Pixel(bounds.left, bounds.bottom)); 
            var ur = map.getLonLatFromPixel(new OpenLayers.Pixel(bounds.right, bounds.top)); 
            var string_bounds = ll.lon.toFixed(4) + ", " + 
                  ll.lat.toFixed(4) + ", " + 
                  ur.lon.toFixed(4) + ", " + 
                  ur.lat.toFixed(4);
            
            console.log("string bounds:" + string_bounds);
            
            var transformed_bounds = bounds.clone().transform(new OpenLayers.Projection("EPSG:900913"), new OpenLayers.Projection("EPSG:32651"));
            console.log("transformed bounds:"+transformed_bounds);
            var filter = new OpenLayers.Filter.Spatial({
                type: OpenLayers.Filter.Spatial.INTERSECTS,
                property: "index",
                //value: transformed_bounds.toGeometry()
                value: bounds.toGeometry()
            });

            var wfs_proto = new OpenLayers.Protocol.WFS({
                version: "1.0.0",
                url: "http://192.168.56.100:8080/geoserver/geonode/wfs",
                featurePrefix: "geonode",
                featureType: "index",
                featureNS: "http://www.geonode.org/",
                geometryName: "the_geom",
                srsName: "EPSG:32651",
            });              
            
            
        }
    });

    OpenLayers.Control.Click = OpenLayers.Class(OpenLayers.Control, {
        defaultHandlerOptions: {
            "single": true,
            "double": false,
            "pixelTolerance": 0,
            "stopSingle": false,
            "stopDouble": false
        },
        
        initialize: function(options) {
            this.handlerOptions = OpenLayers.Util.extend(
                {}, this.defaultHandlerOptions);
            OpenLayers.Control.prototype.initialize.apply(this, arguments);
            
            this.handler = new OpenLayers.Handler.Click(
            this, {
                'click': this.trigger
            }, this.handlerOptions);
        },
        
        trigger: function(e) {
            var lonlat = map.getLonLatFromPixel(e.xy);
            var click_pt = new OpenLayers.Geometry.Point(lonlat.lon, lonlat.lat);
            var transformed_pt = click_pt.transform(map.getProjectionObject(),new OpenLayers.Projection("EPSG:32651"));
            var computed_corners = get_corners(click_pt.x, click_pt.y);
            
            var temp_pt = new OpenLayers.Geometry.Point(computed_corners["ul_x"], computed_corners["ul_y"]);
            
            var tile = {
                georef: "E"+(computed_corners["ul_x"]/1000)+"N"+(computed_corners["ul_y"]/1000),
                corners: computed_corners,
                feature: createHighlightBox(computed_corners)
            }
            console.log(tile);
            if (find_georef(tile_list, tile.georef)<0){
                //tile_attribs["fid"] = "feature_"+tile.georef;
                tile_list.push(tile);
                highlight_layer.addFeatures([tile.feature]);
                console.log(tile_list);
            }else{
                removeHighlight(tile.georef, highlight_layer);
            }
            
             display_points("point_display", highlight_layer);
        }
    });

    click_select = new OpenLayers.Control.Click()

    map.addControl(click_select);
    click_select.activate();
    map.addControl(drawControl);
    drawControl.activate();
    //map.addControl(drawCtrl);
    //drawCtrl.activate();

    app = new GeoExt.MapPanel(config);
    map.zoomToExtent(tile_layer.maxExtent, false);
});
{% endautoescape %}
</script>
